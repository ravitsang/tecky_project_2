<p id="3f21" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">To read the first part of this blog do read:</p><div class="ga gb gc gd ge gf"><a href="https://blog.datahut.co/how-xpath-plays-vital-role-in-web-scraping/" rel="noopener nofollow"><div class="gi n ar"><div class="gj n co p gk gl"><h2 class="bj gm gn bl dc"><div class="eh gg ej ek gh em">How Xpath Plays Vital Role In Web Scraping - Data hut</div></h2><div class="go r"><h3 class="bj ef eg bl bo"><div class="eh gg ej ek gh em">XPath is a language for finding information in structured documents like XML or HTML. You can say that XPath is (sort…</div></h3></div><div class="gp r"><h4 class="bj ef fb bl bo"><div class="eh gg ej ek gh em">blog.datahut.co</div></h4></div></div><div class="gq r"><div class="gr r gs gt gu gq gv gw gx"></div></div></div></a></div><p id="f801" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Here is a piece of content on Xpaths which is the follow up of <a href="https://blog.datahut.co/how-xpath-plays-vital-role-in-web-scraping/" class="at cg gy gz ha hb" target="_blank" rel="noopener nofollow">How Xpath Plays Vital Role In Web Scraping</a></p><p id="f410" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Let’s dive into a real-world example of scraping amazon website for getting information about deals of the day. Deals of the day in amazon can be found at this . So navigate to the (deals of the day) in Firefox and find the XPath selectors. Right click on the deal you like and select “Inspect Element with Firebug”:</p><p id="7188" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">If you observe the image below keenly, there you can find the source of the image(deal) and the name of the deal in src, alt attribute’s respectively. So now let’s write a generic XPath which gathers the name and image source of the product(deal). //img[@role=”img”]/@src ## for image source //img[@role=”img”]/@alt ## for product name</p><p id="87f2" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">In this post, I’ll show you some tips we found valuable when using XPath in the trenches.</p><p id="094b" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">If you have an interest in Python and web scraping, you may have already played with the nice <a href="http://docs.python-requests.org/" class="at cg gy gz ha hb" target="_blank" rel="noopener nofollow">requests library </a>to get the content of pages from the Web. Maybe you have toyed around using <a href="http://doc.scrapy.org/en/latest/topics/selectors.html" class="at cg gy gz ha hb" target="_blank" rel="noopener nofollow">Scrapy selector </a>or to make the content extraction easier. Well, now I’m going to show you some tips I found valuable when using XPath in the trenches and we are going to use both and <a href="http://doc.scrapy.org/en/latest/topics/selectors.html" class="at cg gy gz ha hb" target="_blank" rel="noopener nofollow">Scrapy selector </a>for HTML parsing.</p><p id="20df" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Avoid using expressions which contains(.//text(), ‘search text’) in your XPath conditions. Use contains(., ‘search text’) instead.</p><p id="4019" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Here is why: the expression .//text() yields a collection of text elements — a node-set(collection of nodes).and when a node-set is converted to a string, which happens when it is passed as argument to a string function like contains() or starts-with(), results in the text for the first element only.</p><p id="d30f" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu"><strong class="fo hc">Scrapy Code:</strong></p><p id="4a87" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">from scrapy import Selector<br> html_code = “””&lt;a href=”#”&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;”””<br> sel = Selector(text=html_code)<br> print xp(‘//a//text()’)<br> xp = lambda x: sel.xpath(x).extract() # Let’s type this only once # Take a peek at the node-set<br> [u’Click here to go to the ‘, u’Next Page’] # output of above command<br> print xp(‘string(//a//text())’) # convert it to a string # output of the above command<br> [u’Click here to go to the ‘]</p><p id="7c9f" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Let’s do the above one by using lxml then you can implement XPath by both lxml or Scrapy selector as XPath expression is same for both methods.</p><p id="8134" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu"><strong class="fo hc">lxml code:</strong></p><p id="c85b" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">from lxml import html <br> html_code = “””&lt;a href=”#”&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;””” # Parse the text into a tree<br> parsed_body = html.fromstring(html_code) # Perform xpaths on the tree<br> print parsed_body(‘//a//text()’) # take a peek at the node-set<br> [u’Click here to go to the ‘, u’Next Page’] # output<br> print parsed_body(‘string(//a//text())’) # convert it to a string<br> [u’Click here to go to the ‘] # output</p><p id="93f2" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">A node converted to a string, however, puts together the text of itself plus of all its descendants:</p><p id="c04d" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; xp(‘//a[1]’) # selects the first a node<br> [u’&lt;a href=”#”&gt;Click here to go to the &lt;strong&gt;Next Page&lt;/strong&gt;&lt;/a&gt;’]</p><p id="fdb6" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; xp(‘string(//a[1])’) # converts it to string<br> [u’Click here to go to the Next Page’]</p><p id="e8e3" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Beware of the difference between //node[1] and (//node)[1]//node[1] selects all the nodes occurring first under their respective parents and (//node)[1] selects all the nodes in the document, and then gets only the first of them.</p><p id="5985" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">from scrapy import Selector</p><p id="e668" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">sel = Selector(text=html_code) <br> xp = lambda x: sel.xpath(x).extract()</p><p id="ed97" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">xp(“//li[1]”) # get all first LI elements under whatever it is its parent</p><p id="6e2a" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">xp(“(//li)[1]”) # get the first LI element in the whole document</p><p id="1c09" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">xp(“//ul/li[1]”) # get all first LI elements under an UL parent</p><p id="c35c" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">xp(“(//ul/li)[1]”) # get the first LI element under an UL parent in the document</p><p id="0f99" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">//a[starts-with(@href, ‘#’)][1] gets a collection of the local anchors that occur first under their respective parents and (//a[starts-with(@href, ‘#’)])[1] gets the first local anchor in the document.</p><p id="2399" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">When selecting by class, be as specific as necessary.</p><p id="f85c" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">If you want to select elements by a CSS class, the XPath way to do the same job is the rather verbose:</p><p id="dd8e" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu"><strong class="fo hc">*[contains(concat(‘ ‘, normalize-space(@class), ‘ ‘), ‘ someclass ‘)]</strong></p><p id="7744" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Let’s cook up some examples:</p><p id="b2d6" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; sel = Selector(text=’&lt;p class=”content-author”&gt;Someone&lt;/p&gt;&lt;p class=”content text-wrap”&gt;Some content&lt;/p&gt;’)</p><p id="855f" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; xp = lambda x: sel.xpath(x).extract()</p><p id="6015" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">BAD: because there are multiple classes in the attribute</p><p id="350f" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">[]</p><p id="497f" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">BAD: gets more content than we need</p><p id="3836" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; xp(“//*[contains(@class,’content’)]”)</p><p id="5613" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">[u’&lt;p class=”content-author”&gt;Someone&lt;/p&gt;’, u’&lt;p class=”content text-wrap”&gt;Some content&lt;/p&gt;’]</p><p id="af4a" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; xp(“//*[contains(concat(‘ ‘, normalize-space(@class), ‘ ‘), ‘ content ‘)]”) <br> [u’&lt;p class=”content text-wrap”&gt;Some content&lt;/p&gt;’]</p><p id="7636" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">And many times, you can just use a CSS selector instead, and even combine the two of them if needed:</p><p id="1a5d" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; sel.css(“.content”).extract() <br> [u’&lt;p class=”content text-wrap”&gt;Some content&lt;/p&gt;’]</p><p id="783c" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">&gt;&gt;&gt; sel.css(‘.content’).xpath(‘@class’).extract() <br> [u’content text-wrap’]</p><p id="b107" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Learn to use all the different axes.</p><p id="ef7b" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">It is handy to know how to use the axes, you can follow through these examples .</p><p id="f297" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">In particular, you should note that following and following-sibling are not the same thing, this is a common source of confusion. The same goes for preceding and preceding-sibling, and also ancestor and parent.</p><p id="c9ad" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu"><strong class="fo hc">Useful trick to get text content</strong></p><p id="cc03" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Here is another XPath trick that you may use to get the interesting text contents:</p><p id="8287" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">//*[not(self::script or self::style)]/text()[normalize-space(.)]</p><p id="f0a3" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">This excludes the content from the script and style tags and also skip whitespace-only text nodes.</p><p id="0eb1" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Tools &amp; Libraries Used:</p><p id="f0d3" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Firefox<br> Firefox inspect element with firebug<br> Scrapy : 1.1.1<br> Python : 2.7.12<br> Requests : 2.11.0</p><p id="4d3c" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Have questions? Comment below. Please share if you found this helpful.</p><p id="7c95" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu">Read the original article here: <a href="https://blog.datahut.co/how-xpath-plays-vital-role-in-web-scraping-part-2/" class="at cg gy gz ha hb" target="_blank" rel="noopener nofollow">https://blog.datahut.co/how-xpath-plays-vital-role-in-web-scraping-part-2/</a></p><section class="cu cv cw cx cy"><div class="n p"><div class="ac ae af ag ah cz aj ak"><p id="1b20" class="fm fn dc bk fo b fp fq fr fs ft fu fv fw fx fy fz cu"><em class="hn">Originally published at </em><a href="https://blog.datahut.co/how-xpath-plays-vital-role-in-web-scraping-part-2/" class="at cg gy gz ha hb" target="_blank" rel="noopener nofollow"><em class="hn">https://blog.datahut.co</em></a><em class="hn"> on August 26, 2016.</em></p></div></div></section>